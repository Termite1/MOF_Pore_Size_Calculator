# -*- coding: utf-8 -*-
"""
Created on Thu Jan 23 17:19:10 2025

This file holds functions that help PoreCalculator.

@author: samda
"""
import heapq
import math

from AtomicPoint import AtomicPoint
import NumericMethods as nm

def generateCandidateSpheres(epl, n=150, center=None, **kwargs):
    '''
    Function generates list of candidate spheres that can be created from given
    list of AtomicPoints. Candidate spheres are generated by taking 
    combinations of 3 AtomicPoints and creating the circle the circumscribe. 
    Candidate spheres that intesect other atoms in the environment or are not 
    surrounded (not inside the triangel that an be drawn between the 3 points 
    describing the candidate sphere) are discarded. The returned list is in the 
    form [???] and is returned in decending candidate sphere radius order.

    Parameters
    ----------
    epl : List of AtomicPoints
        List of AtomicPoints describing the molecular pore environment.
    n : Int, optional
        How large the subset of the AtomicPoints closest to the center the pore
        used to generate the candidate spheres should be. The default is 150, 
        but will lower to the amount of atoms in the environment if the number 
        of atom present is less.
    center : AtomicPoint, optional
        Location the subset of AtomicPoints used to generate the canidate 
        spheres is created with respect to the distance to. The default is 
        None, which will cause the function to automatically generate the 
        center at the geometric center of the pore.

    Returns
    -------
    solutionslist : List of [r, cc, [a,b,c], [i1, i2, i3]]
        r is the radius of the candidate sphere. cc is the candidate sphere as
        an AtomicPoint. [a, b, c] are the three AtomicPoints representing the
        atom describing the candidate sphere. [i1, i2, i3] are the indicies of 
        a, b, and c in the .pdb file (pdb files start from index 1).

    '''
    el = len(epl) # Number of atoms in environment
    if el < n: n = el # To stop out of bounds errors
    
    # If no center for calculation given, generates one based on the bounds of the frame.
    if center == None:
        bounds = boundsFinder(epl)
        center = AtomicPoint((bounds[0] + bounds[1]) / 2, (bounds[2] + bounds[3]) / 2, (bounds[4] + bounds[5]) / 2, "")
    
    #Generate limited list of the n nearest AtomicPoints to the center from given list of AtomicPoints.
    ll = listLimiter(center, epl, n)
    
    solutionsList = [] # Holds candidate sphere information
    #Test every three atom combination in the limitedList
    for i in range(0, n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                a = ll[i]
                b = ll[j]
                c = ll[k]
                # Generate circumcenter
                cc = nm.threeAtomCircumcenter(a, b, c)
                r = cc.VanDerWaalsRadius
                
                # Check if candidate sphere radius is large enough, for now just 
                # making sure answers are non-zero
                if r <= 0: continue
                
                # Checks if candidate sphere intersects other environment atoms, 
                # returns invalid result if so
                intersect_flag = False
                for p in epl:
                    if p.distBetween(cc, True) < 0 and p != a and p != b and p != c:
                        intersect_flag = True
                        break
                if intersect_flag: continue
                
                #Takes three given atoms and finds the values for the defined plane
                p_v = nm.getPlanarValues(a, b, c)
                
                #Converts atomic and candidate sphere coordinates to coordinates of new plane
                pa = nm.convertPoint(a, p_v) # Will be at (0,0,0)
                pb = nm.convertPoint(b, p_v)
                pc = nm.convertPoint(c, p_v)
                pcenter = nm.convertPoint(cc, p_v)

                #Checks if the candidate is surrounded, returns invalid if not
                if not nm.circleSurrounded(pa, pb, pc, pcenter): continue
                
                #Grabs list index of surounding atoms
                i1 = epl.index(a)
                i2 = epl.index(b)
                i3 = epl.index(c)

                solutionsList.append([r, cc, [a,b,c], [i1, i2, i3]])
                
    #Check to make sure there is an answer. If not, dummy value created. 
    if len(solutionsList) == 0: solutionsList = [[AtomicPoint(0, 0, 0, ''), 0, [AtomicPoint(0, 0, 0, '')] * 3, [0, 0, 0]]]
      
    solutionslist = sortList(solutionsList)
    return solutionslist


def boundsFinder(apl):
    '''
    Function takes a list of AtomicPoints and produces the maxmum and minimum 
    x, y, z values in an list in the form of [Xmin, Xmax, Ymin, Ymax, Zmin, Zmax]

    Parameters
    ----------
    apl : List of AtomicPoints
        List of AtomicPoints bounds are going to be found for.

    Returns
    -------
    List of floats describing (x,y,z) bounds of given system in the form [Xmin, Xmax, Ymin, Ymax, Zmin, Zmax]
    '''
    Xmin = apl[0].x 
    Xmax = apl[0].x 
    Ymin = apl[0].y 
    Ymax = apl[0].y 
    Zmin = apl[0].z 
    Zmax = apl[0].z 

    # Goes through every AtomicPoint in list   
    for p in apl: 
        if p.x > Xmax:   Xmax = p.x 
        elif p.x < Xmin: Xmin = p.x 
        if p.y > Ymax:   Ymax = p.y 
        elif p.y < Ymin: Ymin = p.y 
        if p.z > Zmax:   Zmax = p.z 
        elif p.z < Zmin: Zmin = p.z 
    
    return [Xmin, Xmax, Ymin, Ymax, Zmin, Zmax]


def centering(c, frame, revert=False):
    '''
    Function shifts frame atoms so center is at (0,0,z) or retverts points to 
    positon based on the center's initial position.

    Parameters
    ----------
    c : AtomicPoint
        Location with respect to pore that will become the (x,y) center (0,0,z)
    frame : List of AtomicPoints
        List of AtomicPoints describing pore.
    revert : Boolean, optional
        If False, subtracts center position (Transforms so center is at (0,0,z))
        If True, adds center position (Reverts to original pore location) 
        The default is False.

    Returns
    -------
    List of AtomicPoints. Either centered on c, or returned to original position relative to c.

    '''
    if revert: return [AtomicPoint(p.x + c.x, p.y + c.y, p.z, p.element, vdwr=p.VanDerWaalsRadius, bondType = p.bondType) for p in frame]
    else: return [AtomicPoint(p.x - c.x, p.y - c.y, p.z, p.element, vdwr=p.VanDerWaalsRadius, bondType = p.bondType) for p in frame]


def listLimiter(a, apl, n, **kwargs):
    '''
    Function takes a list of AtomicPoints and returns a new list of length n 
    containing the n closest points to AtomicPoint a

    Parameters
    ----------
    a : AtomicPoint
        Location the distance of AtomicPoints in apl are checked against.
    apl : List of AtomicPoints
        List of AtomicPoints being examined.
    n : Int
        Number of AtomicPoints to return.

    Returns
    -------
    limitedList : List of AtomicPoints
        List of the n closest AtomicPoints in apl to AtomicPoint a.

    '''
    distList = []
    limitedList = []
    distDict = {}
    
    #For loop runs through each item in list, calulates distance to given point
    #records that point in a new list, and records the distance:AtomicPoint pair 
    #with the distance as the key in a dictionary
    for p in apl:
        d = a.distBetween(p, True)
        # Ensure duplicates are not in list
        while d in distList: d += 1E-12
        #update dictionary
        add = {d : p}
        distDict.update(add)
        distList.append(d)
    
    #Finds the produces a size length list of the smallest distances in the distance list    
    valList = heapq.nsmallest(n, distList)
    
    #Fills limited list with the AtomicPoints associate with the size smallest distances.
    for v in valList:
        limitedList.append(distDict.pop(v))
        
    return limitedList


def sortList(l, sort_index = 0):
    '''
    Sorts given list in decending orber based on float value in indicated list
    index.
    
    Code derived from https://www.geeksforgeeks.org/sorting-algorithms-in-python/#

    Parameters
    ----------
    l : List of Lists
        Component lists must have a number in one of their indecies. Number can
        be float or int.
    sort_index : Int, optional
        Index of column of numbers lists will be sorted by. The default is 0.

    Returns
    -------
    nl : List of Lists
        List l sorted in decending order based on values in column sort_index.
    '''
    nl = [] # New list to be returned
    for i in range(len(l)): # Go through every value in list l
        largest_index = -math.inf
        largest_val = -math.inf
        for j in range(len(l)): # Go through every remaining value in list l
            if l[j][sort_index] > largest_val: 
                largest_val = l[j][sort_index]
                largest_index = j
        nl.append(l.pop(largest_index))
    return nl